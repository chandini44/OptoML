
module pipeline_register #(
    parameter WIDTH = 32
)(
    input  logic                  clk,
    input  logic                  rst_n,   // active-low reset

    input  logic                  in_valid,
    input  logic [WIDTH-1:0]      in_data,
    output logic                  in_ready,

    output logic                  out_valid,
    output logic [WIDTH-1:0]      out_data,
    input  logic                  out_ready
);

    logic [WIDTH-1:0] data_reg;
    logic             valid_reg;

    // Ready when buffer is empty or downstream can accept
    assign in_ready  = ~valid_reg || out_ready;

    assign out_valid = valid_reg;
    assign out_data  = data_reg;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            valid_reg <= 1'b0;
            data_reg  <= '0;
        end
        else begin
            case ({in_valid && in_ready, out_valid && out_ready})
                2'b10: begin
                    // New data accepted
                    data_reg  <= in_data;
                    valid_reg <= 1'b1;
                end

                2'b01: begin
                    // Data consumed, buffer empty
                    valid_reg <= 1'b0;
                end

                2'b11: begin
                    // Pass-through: replace old data with new
                    data_reg  <= in_data;
                    valid_reg <= 1'b1;
                end

                default: begin
                    // Hold state
                    valid_reg <= valid_reg;
                end
            endcase
        end
    end

endmodule


`timescale 1ns/1ps

module tb_pipeline_register;

    parameter WIDTH = 32;

    logic clk;
    logic rst_n;

    logic in_valid;
    logic [WIDTH-1:0] in_data;
    logic in_ready;

    logic out_valid;
    logic [WIDTH-1:0] out_data;
    logic out_ready;

    // DUT
    pipeline_register #(
        .WIDTH(WIDTH)
    ) dut (
        .clk       (clk),
        .rst_n     (rst_n),
        .in_valid  (in_valid),
        .in_data   (in_data),
        .in_ready  (in_ready),
        .out_valid (out_valid),
        .out_data  (out_data),
        .out_ready (out_ready)
    );

    // Clock: 10ns period
    always #5 clk = ~clk;

    initial begin
        clk = 0;
        rst_n = 0;

        in_valid = 0;
        in_data  = 0;
        out_ready = 0;

        // Apply reset
        #20;
        rst_n = 1;

        // -------------------------
        // Test 1: Normal transfer
        // -------------------------
        @(posedge clk);
        in_valid  <= 1;
        in_data   <= 32'hA5A5_A5A5;
        out_ready <= 1;

        @(posedge clk);
        in_valid  <= 0;

        // -------------------------
        // Test 2: Backpressure
        // -------------------------
        @(posedge clk);
        in_valid  <= 1;
        in_data   <= 32'h1111_1111;
        out_ready <= 0;   // Stall output

        repeat (2) @(posedge clk);

        out_ready <= 1;   // Release backpressure
        in_valid  <= 0;

        // -------------------------
        // Test 3: Pass-through
        // -------------------------
        @(posedge clk);
        in_valid  <= 1;
        in_data   <= 32'h2222_2222;
        out_ready <= 1;

        @(posedge clk);
        in_valid  <= 1;
        in_data   <= 32'h3333_3333;
        out_ready <= 1;

        @(posedge clk);
        in_valid <= 0;

        // Finish simulation
        #50;
        $finish;
    end

    // Monitor for visibility
    initial begin
        $display("Time  | in_v in_r | out_v out_r | out_data");
        $monitor("%4t |   %0b    %0b |    %0b     %0b | %h",
                 $time, in_valid, in_ready,
                 out_valid, out_ready,
                 out_data);
    end

endmodule

